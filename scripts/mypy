#!/usr/bin/env python
"""Mypy type checker, runner and prototype compiler.

Type check and program and run it using a Python interpreter, or
compile it to C and run it.

Note that the C back end is early in development and has a very
limited feature set.
"""

import os
import os.path
import subprocess
import sys

import click

import typing
from typing import List

from mypy import build
from mypy.errors import CompileError


@click.command()
@click.option('-m', '--module', is_flag=True,
              help="check and run module as a script.")
@click.option('-S', '--only-check', is_flag=True,
              help="only check; do not run program or module")
@click.option('--verbose', is_flag=True, help="more verbose message")
@click.option('--html-report', metavar='dir', type=click.Path(exists=True),
              help="type check and generate a report of type checking precision under dir/, "
              "do not run the program")
@click.option('-c', is_flag=True)
@click.option('--stats', is_flag=True)
@click.option('--inferstats', is_flag=True)
@click.option('--custom-typing')
@click.option('--py2', metavar="INTERPRETER")
@click.option('--mypypath', envvar='MYPYPATH',
              help='additional module search path (ENVVAR: MYPYPATH)',
              type=click.Path(exists=True))
@click.argument('PATH', type=click.Path(exists=True))
def main(path, module, only_check, verbose, html_report, c, stats, inferstats, custom_typing, py2, mypypath) -> None:
    build_flags = List[str]()
    if verbose:
        build_flags.append(build.VERBOSE)
    if only_check:
        build_flags.append(build.COMPILE_ONLY)
    if stats:
        build_flags.append('dump-type-stats')
    if inferstats:
        build_flags.append('dump-infer-stats')
    if html_report:
        build_flags.append('html-report')

    if py2:
        interpreter = py2
    elif sys.executable:
        interpreter = sys.executable
    else:
        interpreter = 'python'
    pyversion = 2 if py2 else 3
    target = build.C if c else build.TYPE_CHECK
    bin_dir = find_bin_directory()

    # TODO: mutually exclude path and module in CLI
    if module:
        path = None

    try:
        # TODO: Move assertions into click parser assertions
        if c == build.C:
            assert not module # Not supported yet
            assert pyversion == 3

        print(target)
        result = build.build(path,
                             module=module,
                             bin_dir=bin_dir,
                             target=target,
                             pyversion=pyversion,
                             custom_typing_module=custom_typing,
                             html_report_dir=html_report,
                             flags=build_flags)

        if build.COMPILE_ONLY not in build_flags:
            if c == build.TYPE_CHECK:
                # TODO: Implement arg pass-through
                status = interpret(pyversion, interpreter, path, module, [])
            elif c == build.C:
                status = run_compiled(result)
            else:
                raise RuntimeError('unsupported target %d' % target)
            sys.exit(status)
    except CompileError as e:
        for m in e.messages:
            sys.stderr.write(m + '\n')
        sys.exit(1)


def find_bin_directory() -> str:
    """Find the directory that contains this script.

    This is used by build to find stubs and other data files.
    """
    script = __file__
    # Follow up to 5 symbolic links (cap to avoid cycles).
    for _ in range(5):
        if os.path.islink(script):
            script = readlinkabs(script)
        else:
            break
    return os.path.dirname(script)


def readlinkabs(link: str) -> str:
    """Return an absolute path to symbolic link destination."""
    # Adapted from code by Greg Smith.
    assert os.path.islink(link)
    path = os.readlink(link)
    if os.path.isabs(path):
        return path
    return os.path.join(os.path.dirname(link), path)


def interpret(pyversion, interpreter, path, module, args) -> None:
    # Run the translated program.
    if module:
        opts = ['-m', module]
    else:
        opts = [path]
    if (pyversion == 2 and
            os.path.dirname(typing.__file__).endswith(
                os.path.join('lib-typing', '3.2')) and
            os.path.isdir('lib-typing')):
        # We are running Python 2.x test cases and we must force the 2.x
        # typing module to be used.
        os.environ['PYTHONPATH'] = os.path.join('lib-typing', '2.7')
    return subprocess.call([interpreter] + opts + args)


def run_compiled(result) -> None:
    # Run the compiled program.
    # TODO command line arguments
    return subprocess.call([result.binary_path])


if __name__ == '__main__':
    main()
