#!/usr/bin/env python
"""Mypy type checker, runner and prototype compiler.

Type check and program and run it using a Python interpreter, or
compile it to C and run it.

Note that the C back end is early in development and has a very
limited feature set.
"""

import os
import subprocess
import sys
import shlex

import click

import typing
from typing import List

from mypy import build
from mypy.errors import CompileError


def parse_target(ctx:click.Context, _:str, val:str):
    """Parses and validates the use of the target flag."""
    if val == 'c':
        if ctx.params['module'] or ctx.params['py2']:
            raise click.BadParameter(
                'Cannot enable module or py2 with c build target.')
        return build.C
    return build.TYPE_CHECK


def parse_interpreter(ctx:click.Context, _:str, interpreter:str):
    if ctx.params['py2']:
        interpreter = py2
    elif sys.executable:
        interpreter = sys.executable
    return interpreter


@click.command()
@click.option('-m', '--module',
              help="run library module as a script (terminates option list)")
@click.option('-S', '--only-check', is_flag=True,
              help="only check; do not run program or module")
@click.option('--verbose', is_flag=True, help="more verbose message")
@click.option('--html-report', metavar='dir', type=click.Path(exists=True),
              help="type check and generate a report of type checking precision under dir/, "
              "do not run the program")
@click.option('--py2', is_flag=True)
@click.option('--target', default='type_check', type=click.Choice(['c', 'type_check']),
              callback=parse_target)
@click.option('--stats', is_flag=True)
@click.option('--inferstats', is_flag=True)
@click.option('--interpreter', callback=parse_interpreter, default='python')
@click.option('--custom-typing')
@click.option('--mypypath', envvar='MYPYPATH',
              help='additional module search path (ENVVAR: MYPYPATH)',
              type=click.Path(exists=True))
@click.option('--pass-through-args', default="", callback=lambda ctx, param, val: shlex.split(val))
@click.argument('PATH', type=click.Path(exists=True))
def main(path:str, module:str, only_check:bool, verbose:bool, html_report:str,
         target:int, stats:bool, inferstats:bool, custom_typing:str, py2:bool,
         mypypath:str, pass_through_args:List[str], interpreter:str) -> None:
    build_flags = List[str]()
    if verbose:
        build_flags.append(build.VERBOSE)
    if only_check:
        build_flags.append(build.COMPILE_ONLY)
    if stats:
        build_flags.append('dump-type-stats')
    if inferstats:
        build_flags.append('dump-infer-stats')
    if html_report:
        build_flags.append('html-report')

    pyversion = 2 if py2 else 3
    bin_dir = find_bin_directory()

    if module:
        module, path = path, None  # Hack because of the way build exepects it

    try:
        result = build.build(path,
                             module=module,
                             bin_dir=bin_dir,
                             target=target,
                             pyversion=pyversion,
                             custom_typing_module=custom_typing,
                             html_report_dir=html_report,
                             flags=build_flags)

        if build.COMPILE_ONLY not in build_flags:
            if target == build.TYPE_CHECK:
                status = interpret(pyversion, interpreter, path, module, pass_through_args)
            elif target == build.C:
                status = run_compiled(result)
            sys.exit(status)
    except CompileError as e:
        for m in e.messages:
            sys.stderr.write(m + '\n')
        sys.exit(1)


def find_bin_directory() -> str:
    """Find the directory that contains this script.

    This is used by build to find stubs and other data files.
    """
    script = __file__
    # Follow up to 5 symbolic links (cap to avoid cycles).
    for _ in range(5):
        if os.path.islink(script):
            script = readlinkabs(script)
        else:
            break
    return os.path.dirname(script)


def readlinkabs(link: str) -> str:
    """Return an absolute path to symbolic link destination."""
    # Adapted from code by Greg Smith.
    assert os.path.islink(link)
    path = os.readlink(link)
    if os.path.isabs(path):
        return path
    return os.path.join(os.path.dirname(link), path)


def interpret(pyversion:int, interpreter:str, path:str, module:bool, args:List[str]) -> None:
    # Run the translated program.
    if module:
        opts = ['-m', path]
    else:
        opts = [path]
    if (pyversion == 2 and
            os.path.dirname(typing.__file__).endswith(
                os.path.join('lib-typing', '3.2')) and
            os.path.isdir('lib-typing')):
        # We are running Python 2.x test cases and we must force the 2.x
        # typing module to be used.
        os.environ['PYTHONPATH'] = os.path.join('lib-typing', '2.7')
    return subprocess.call([interpreter] + opts + args)


def run_compiled(result) -> None:
    # Run the compiled program.
    # TODO command line arguments
    return subprocess.call([result.binary_path])


if __name__ == '__main__':
    main()
